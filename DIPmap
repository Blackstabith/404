#!/usr/bin/env python3

import argparse
import os
import socket
import requests
import time
import logging
from concurrent.futures import ThreadPoolExecutor

# Logging configuration
logging.basicConfig(filename="dipmap_errors.log", level=logging.ERROR, format="%(asctime)s - %(message)s")

# Predefined port lists
DEFAULT_PORTS = [80, 443, 8080, 8443]
QUICK_SCAN_PORTS = [21, 22, 80, 443]

def log_error(error_message):
    """Log errors to a file."""
    logging.error(error_message)

def parse_args():
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(description="DIPmap: Map domains to IPs and check HackerOne scope.")
    parser.add_argument('-d', '--domain', help="Single domain to check")
    parser.add_argument('-f', '--file', help="File containing list of domains")
    parser.add_argument('-I', '--ip', help="Show IP addresses", action='store_true')
    parser.add_argument('-V', '--version', help="Show version information", action='store_true')
    parser.add_argument('-G', '--geolocation', help="Show geolocation of IP addresses", action='store_true')
    parser.add_argument('-S', '--check-scope', help="Check if the domain is in scope on HackerOne", action='store_true')
    parser.add_argument('-P', '--port-scan', help="Perform a port scan on the domain's IPs", action='store_true')
    parser.add_argument('--quick-scan', help="Perform a quick port scan", action='store_true')
    parser.add_argument('-p', '--ports', help="Comma-separated list of ports to scan (e.g., 22,53,80)")
    return parser.parse_args()

def parse_custom_ports(port_string):
    """Parse a comma-separated list of ports."""
    try:
        return [int(port.strip()) for port in port_string.split(',')]
    except ValueError:
        print("Error: Ports must be a comma-separated list of integers.")
        exit(1)

def get_ips(domain):
    """Resolve IP addresses for a domain."""
    try:
        return socket.gethostbyname_ex(domain)[2]
    except socket.gaierror:
        print(f"Error: Unable to resolve IP addresses for {domain}")
        return []

def get_geolocation(ip):
    """Fetch geolocation data for an IP address."""
    try:
        response = requests.get(f"http://ip-api.com/json/{ip}", timeout=5)
        response.raise_for_status()
        data = response.json()
        if data['status'] == 'fail':
            return f"Geolocation data unavailable for {ip}"
        return f"IP: {ip} - Country: {data['country']}, Region: {data['regionName']}, City: {data['city']}"
    except requests.exceptions.RequestException as e:
        log_error(f"Error fetching geolocation for {ip}: {e}")
        return f"Error: {e}"

def get_version(ip):
    """Get server version information from HTTP headers."""
    try:
        response = requests.get(f"http://{ip}", timeout=5)
        response.raise_for_status()
        return response.headers.get('Server', 'No server info')
    except requests.exceptions.RequestException as e:
        log_error(f"Error retrieving version for {ip}: {e}")
        return None

def check_hackerone_scope(domain):
    """Check if a domain is in scope on HackerOne."""
    api_key = os.getenv('HACKERONE_API_KEY')
    if not api_key:
        print("Error: API key not found. Please set it as an environment variable.")
        return None

    url = f"https://api.hackerone.com/v1/targets?filter[domain]={domain}"
    headers = {"Authorization": f"Bearer {api_key}"}

    try:
        response = requests.get(url, headers=headers)
        if response.status_code == 200:
            data = response.json()
            return bool(data['data'])
        else:
            print(f"Error: {response.status_code}, {response.text}")
            return None
    except requests.exceptions.RequestException as e:
        log_error(f"Error checking scope for {domain}: {e}")
        return None

def scan_port(ip, port, timeout=2):
    """Scan a single port."""
    try:
        with socket.create_connection((ip, port), timeout=timeout):
            return port
    except (socket.timeout, socket.error):
        return None

def port_scan(ip, ports, timeout=2, threads=4):
    """Perform a port scan."""
    open_ports = []
    with ThreadPoolExecutor(max_workers=threads) as executor:
        results = executor.map(lambda port: scan_port(ip, port, timeout), ports)
        for port, result in zip(ports, results):
            if result:
                open_ports.append(result)
    return open_ports

def perform_port_scan(ip, quick=False, custom_ports=None, timeout=2, threads=4):
    """Handle port scanning with quick or custom options."""
    if custom_ports:
        ports_to_scan = custom_ports
        print(f"Performing custom port scan for {ip}...")
    elif quick:
        ports_to_scan = QUICK_SCAN_PORTS
        print(f"Performing quick port scan for {ip}...")
    else:
        ports_to_scan = DEFAULT_PORTS
        print(f"Performing full port scan for {ip}...")
    
    open_ports = port_scan(ip, ports_to_scan, timeout, threads)
    if open_ports:
        print(f"Open ports for {ip}: {', '.join(map(str, open_ports))}")
    else:
        print(f"No open ports detected for {ip}.")

# Function to print the script banner
def print_banner():
    banner = r"""
     ____  _______ ____   __  __    _    ____  
    |  _ \|__  __||    \ |  \/  |  / \  |  _ \ 
    | | | |  | |  | |_) || |\/| | / _ \ | |_) |
    | |_| |__| |__|  __/ | |  | |/ ___ \|  __/ 
    |____/|_______|__|   |_|  |_/_/   \_\_|  

                     DIPmap
                Map Domains to IPs
                 """
    print(banner)

def main():
    args = parse_args()
    
    print_banner()
    if args.domain:
        ip_addresses = get_ips(args.domain)
        if ip_addresses:
            print(f"IP Addresses for {args.domain}: {', '.join(ip_addresses)}")

            if args.geolocation:
                for ip in ip_addresses:
                    print(get_geolocation(ip))

            if args.version:
                for ip in ip_addresses:
                    version = get_version(ip)
                    if version:
                        print(f"Version info for {ip}: {version}")
                    else:
                        print(f"Could not retrieve version info for {ip}")

            if args.port_scan or args.quick_scan or args.ports:
                custom_ports = parse_custom_ports(args.ports) if args.ports else None
                for ip in ip_addresses:
                    perform_port_scan(ip, quick=args.quick_scan, custom_ports=custom_ports)
        else:
            print(f"Could not resolve IP addresses for {args.domain}.")

if __name__ == "__main__":
    main()
